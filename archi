#!/bin/bash

#     _             _     _ _  ___ _       _
#    / \   _ __ ___| |__ (_) |/ (_) |_ ___| |__   ___ _ __
#   / _ \ | '__/ __| '_ \| | ' /| | __/ __| '_ \ / _ \ '_ \
#  / ___ \| | | (__| | | | | . \| | || (__| | | |  __/ | | |
# /_/   \_\_|  \___|_| |_|_|_|\_\_|\__\___|_| |_|\___|_| |_|
#
# Copyright 2014 ≈Åukasz "JustArchi" Domeradzki
# Contact: JustArchi@JustArchi.net
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# cd to the diectory of this script automatically
cd "$(dirname "$0")"

# Initial variables
VERSION="1.0" # Unused
TOOLS=(which whoami basename dirname gcc java perl sed cut wget od wc cpio zip unzip tar)
XDALINK="http://forum.xda-developers.com/showthread.php?t=2597220"
GITHUBLINK="https://github.com/JustArchi/ArchiKitchen.git"
AUTOUPDATE="1" # Defines if we should turn on auto updates, if available
GITHUBBRANCH="master"
NEEDEDGIT="1.8"

ACTIVE_PROJECT=""
ARCH="unknown"
CUSER="$(whoami)"

ALIGN=4
FULLPERFORMANCE=1

META_INF="META-INF/com/google/android"
UPDATER_SCRIPT_HEAD="updater-script-00_HEAD" # Unused
UPDATER_SCRIPT_SYMLINKS="updater-script-10_SYMLINKS"
UPDATER_SCRIPT_PERMISSIONS="updater-script-20_PERMISSIONS"
UPDATER_SCRIPT_EXEC="updater-script-80_EXEC" # Unused
UPDATER_SCRIPT_USER="updater-script-85_USER" # Unused
UPDATER_SCRIPT_KERNEL="updater-script-90_KERNEL"
UPDATER_SCRIPT_MODEM="updater-script-91_MODEM"
UPDATER_SCRIPT_TAIL="updater-script-99_TAIL" # Unused

#  _____                 _   _
# |  ___|   _ _ __   ___| |_(_) ___  _ __  ___
# | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
# |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
# |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#

### CORE ###

# Waits for user action
PRESS_ENTER() {
	read -p "Press [Enter] key to continue..."
}

# Executes commands given in arguments as root
ROOT_EXECUTE() {
	if [[ "$CUSER" = "root" ]]; then
		$@ # Yes, we must break on spaces in this case
	else
		echo "Root access is required! $@"
		if [[ ! -z "$(which sudo)" ]]; then
			sudo $@ # Yes, we must break on spaces in this case
		else
			su -c $@ # Yes, we must break on spaces in this case
		fi
	fi
}

# Compares two versions
VERSION_LESS_THAN() {
	# $1 - Input version
	# $2 - Compared version
	# Returns true if $1 < $2, false otherwise
	if [[ "$1" != "$2" && "$(echo -e "$1\n$2" | sort -V | head -n 1)" = "$1" ]]; then
		return 0
	else
		return 1
	fi
}

# Changes matching word to another one
SED_CHANGE_WORD() {
	# $1 - What we're changing
	# $2 - To what we're changing
	# $3 - File location for that
	# $4 - Unique delimiter (optional)
	if [[ -z "$4" ]]; then
		sed -i 's/'"$1"'/'"$2"'/g' "$3"
	else
		sed -i 's'"$4""$1""$4""$2""$4"'g' "$3"
	fi
}

# Removes all lines which match the word
GREP_DELETE_WORD() {
	# $1 - What we're deleting
	# $2 - File location for that
	grep -v "$1" "$2" > "$2.tmp" && mv -f "$2.tmp" "$2"
}

# Deletes files/folders based on given blacklist
BLACKLIST_REMOVE() {
	if [[ -f "files/$1/blacklist_files.txt" ]]; then
		while read line; do
			if [[ -f "$ACTIVE_PROJECT$line" ]]; then
				echo "Removing $line"
				rm -f "$ACTIVE_PROJECT$line"
			fi
		done < "files/$1/blacklist_files.txt"
	fi

	if [[ -f "files/$1/blacklist_folders.txt" ]]; then
		while read line; do
			if [[ -d "$ACTIVE_PROJECT$line" ]]; then
				echo "Removing $line"
				rm -rf "$ACTIVE_PROJECT$line"
			fi
		done < "files/$1/blacklist_folders.txt"
	fi

	if [[ -f "files/$1/blacklist_everything.txt" ]]; then
		while read line; do
			if [[ -e "$ACTIVE_PROJECT$line" ]]; then
				echo "Removing $line"
				rm -rf "$ACTIVE_PROJECT$line"
			fi
		done < "files/$1/blacklist_everything.txt"
	fi
}

# Tries to mount chosen file
TRY_MOUNT() {
	# $1 - File to mount
	# $2 - Directory to mount file into
	echo "Trying to mount $(basename "$1")"
	mkdir -p /tmp/ArchiKitchenLOOP
	echo "Stage 1: Mounting with automatic filesystem..."
	ROOT_EXECUTE "mount -t auto -o loop $1 $2"
	if [[ $? -eq 0 ]]; then
		echo "Success!"
		return 0
	fi
	echo "Failed!"
	echo "Stage 2: Checking if image is in special sparse ext4 format available for conversion..."
	if [[ "$(od -A n -h -N 5 "$1" | sed 's/ //g')" = "ff3aed260001" ]]; then
		echo "Yes it is!"
		if [[ ! -x "TEMP/simg2img" ]]; then
			echo "Compiling simg2img..."
			mkdir -p "TEMP"
			gcc -O2 "tools/simg2img/sparse_crc32.c" "tools/simg2img/simg2img.c" -o "TEMP/simg2img"
		fi
		echo "Converting sparse image to image..."
		./TEMP/simg2img "$1" "$1".simg2img
		if [[ $? -ne 0 ]]; then
			echo "Conversion failed"
			PRESS_ENTER
		else
			mv -f "$1".simg2img "$1"
			echo "Mounting converted image..."
			ROOT_EXECUTE "mount -t auto -o loop $1 $2"
			if [[ $? -eq 0 ]]; then
				echo "Success!"
				return 0
			fi
		fi
		echo "Failed!"
	else
		echo "It doesn't look like sparse ext4 file"
	fi
	echo "Sorry, all stages failed, we're not able to extract files from this image in any implemented way"
	echo "Either it's not a valid partition image, or we don't know how to mount it"
	PRESS_ENTER
	return 1
}

# Removes ACTIVE_PROJECT
DEL_PROJECT() {
	echo "Cleaning $ACTIVE_PROJECT"
	rm -rf "$ACTIVE_PROJECT"
	ACTIVE_PROJECT=""
}

# Creates new project
SET_NEWPROJECT() {
	clear
	PRINT_BANNER
	echo "Before you begin, you must specify what kind of the project you want to create"
	echo
	echo "b - Create a Bare Bones project"
	echo "i - Create a ZIP-flashable ROM from stock partition image(s)"
	echo "z - Create a ZIP-flashable ROM from other ZIP-flashable ROM"
	echo
	read -p "Which choice describes your case? [B/i/z]: " CHOICE
	case "$CHOICE" in
		i|I) NEWPROJECT_STOCK ;;
		z|Z) NEWPROJECT_ZIP ;;
		*) NEWPROJECT_BARE ;;
	esac
}

# Sets ACTIVE_PROJECT
SET_PROJECT() {
	echo
	echo "You currently don't have any active project set"
	echo "You can open any project you've created in the past or create a new one:"
	echo
	echo "n - Create a new project"
	echo "e - Use existing project"
	echo "x - Exit"
	read -p "Your choice: " CHOICE
	case "$CHOICE" in
		n|N) SET_NEWPROJECT ;;
		e|E) SET_OLDPROJECT ;;
		*) exit 0 ;;
	esac
}

# Sets old project as active one
SET_OLDPROJECT() {
	clear
	PRINT_BANNER
	local COUNT=0
	local LASTFOUND=""
	echo "Searching for projects you've created in the past..."
	echo "=-=-=-=-=-=-=-=-="
	while read line; do
		((COUNT++))
		LASTFOUND="$line"
		basename "$LASTFOUND"
	done < <(find . -type d -iname "PROJECT_*") # Avoid a subshell, because we must remember variables
	echo "=-=-=-=-=-=-=-=-="
	echo "Found total of $COUNT projects"
	if [[ "$COUNT" -eq 1 ]]; then
		ACTIVE_PROJECT="$(basename "$LASTFOUND")" # If we have only one project, there's nothing to choose from, so we can save some precious seconds
		return 0
	fi
	echo "Write a name of any from the projects detected above or 'x' to go back"
	read -p "Your selected project: " CHOICE
	case "$CHOICE" in
		x|X) return ;;
		*)
			CHOICE="$(basename "$CHOICE")"
			if [[ -d "$CHOICE" ]]; then
				ACTIVE_PROJECT="$CHOICE"
			else
				echo "Invalid selection"
				PRESS_ENTER
			fi
		;;
	esac
}

# Creates a new bare project
NEWPROJECT_BARE() {
	ACTIVE_PROJECT="PROJECT_"
	ACTIVE_PROJECT+="$(date '+%m%d%y_%H%M%S')"
	mkdir -p "$ACTIVE_PROJECT/system"
	BUILD_META_INF
	BUILD_UPDATER_SCRIPT
}

# Creates a new stock image-based project
NEWPROJECT_STOCK() {
	echo "To create a ROM from stock partition images, make sure that you have:"
	echo
	echo "[REQUIRED] system.img - Partition image for /system partition"
	echo "[REQUIRED] boot.img - Raw kernel image for boot block"
	echo "[OPTIONAL] cache.img - Partition image for /cache partition"
	echo "[OPTIONAL] modem.bin - Raw modem image for modem block"
	echo
	echo "Please notice that some ROMs may have other requirements, for example having cache.img as mandatory and not optional"

	local READY=0
	while [[ $READY -eq 0 ]]; do
		echo
		echo "Please fill a path for your system.img file"
		echo "Potential candidates:"
		echo "=-=-=-=-=-=-=-=-="
		find base_drops/ -type f -iname "*system*"
		echo "=-=-=-=-=-=-=-=-="
		read -p "system.img: " SYSTEMIMG

		echo
		echo "Please fill a path for your boot.img file"
		echo "Potential candidates:"
		echo "=-=-=-=-=-=-=-=-="
		find base_drops/ -type f -iname "*boot*"
		echo "=-=-=-=-=-=-=-=-="
		read -p "boot.img: " BOOTIMG

		echo
		echo "Please fill a path for your cache.img file. Leave empty if you don't have one"
		echo "Potential candidates:"
		echo "=-=-=-=-=-=-=-=-="
		find base_drops/ -type f -iname "*cache*"
		echo "=-=-=-=-=-=-=-=-="
		read -p "cache.img: " CACHEIMG

		echo
		echo "Please fill a path for your modem.bin file. Leave empty if you don't have one"
		echo "Potential candidates:"
		echo "=-=-=-=-=-=-=-=-="
		find base_drops/ -type f -iname "*modem*"
		echo "=-=-=-=-=-=-=-=-="
		read -p "modem.bin: " MODEMIMG

		if [[ -f "$SYSTEMIMG" && -f "$BOOTIMG" ]] && ([[ -z "$CACHEIMG" || -f "$CACHEIMG" ]]) && ([[ -z "$MODEMIMG" || -f "$MODEMIMG" ]]); then
			READY=1
		else
			echo "Some of your files do not exist"
			PRESS_ENTER
		fi
	done

	ACTIVE_PROJECT="PROJECT_$(date '+%m%d%y_%H%M%S')"
	echo "Creating $ACTIVE_PROJECT"
	mkdir -p "$ACTIVE_PROJECT/system"

	# KERNEL
	cp "$BOOTIMG" "$ACTIVE_PROJECT/boot.img"

	# SYSTEM
	cp "$SYSTEMIMG" "$ACTIVE_PROJECT/system.img"
	TRY_MOUNT "$ACTIVE_PROJECT/system.img" "/tmp/ArchiKitchenLOOP" || (DEL_PROJECT; return 1)
	echo "Extracting everything from mounted system partition..."
	ROOT_EXECUTE "cp -R /tmp/ArchiKitchenLOOP/* $ACTIVE_PROJECT/system/"
	umount /tmp/ArchiKitchenLOOP
	rm -f "$ACTIVE_PROJECT/system.img"

	# CACHE
	if [[ ! -z "$CACHEIMG" ]]; then
		cp "$CACHEIMG" "$ACTIVE_PROJECT/cache.img"
		TRY_MOUNT "$ACTIVE_PROJECT/cache.img" "/tmp/ArchiKitchenLOOP"
		if [[ -f "/tmp/ArchiKitchenLOOP/recovery/sec_csc.zip" ]]; then
			echo "Found common Samsung sec_csc.zip file, extracting it and merging with the project"
			ROOT_EXECUTE "unzip -q /tmp/ArchiKitchenLOOP/recovery/sec_csc.zip -d $ACTIVE_PROJECT/"
		else
			echo "Could not detect any known cache format"
			echo "This is typical when cache doesn't contain any valuable files, such as sec_csc.zip in case of Samsung ROMs"
			echo "Extract everything you need from /tmp/ArchiKitchenLOOP before going to the next step"
			PRESS_ENTER
		fi
		umount /tmp/ArchiKitchenLOOP
		rm -f "$ACTIVE_PROJECT/cache.img"
	fi

	# MODEM
	if [[ ! -z "$MODEMIMG" ]]; then
		cp "$MODEMIMG" "$ACTIVE_PROJECT/modem.bin"
	fi

	# Fix permissions
	ROOT_EXECUTE "chown -hR $CUSER.$CUSER $ACTIVE_PROJECT"
	ROOT_EXECUTE "chmod -R 755 $ACTIVE_PROJECT"

	# Generate required files
	rm -rf "$ACTIVE_PROJECT/META-INF" # In case we have any bloat from sec_csc.zip or similar
	BUILD_META_INF
	BUILD_UPDATER_SCRIPT
	PRESS_ENTER
	SET_KERNEL
	SET_MODEM
}

# Creates a new zip-based project
NEWPROJECT_ZIP() {
	NEWPROJECT_BARE # TODO
}

# Sets kernel
SET_KERNEL() {
	if [[ -f "$ACTIVE_PROJECT/boot.img" ]] && ([[ "$(grep -qi "boot.img" "$ACTIVE_PROJECT/$META_INF/updater-script"; echo $?)" -ne 0 || "$(grep -qi "/tmp/invalid_kernel_path" "$ACTIVE_PROJECT/$META_INF/updater-script"; echo $?)" -eq 0 ]]); then
		clear
		PRINT_BANNER
		echo "WARNING! Kernel has been found but there's no path in the current updater-script"
		echo "This is typical when you're converting stock image partition to ZIP-flashable ROM"
		local MODEL="$(grep -i "ro.product.device" "$ACTIVE_PROJECT/system/build.prop" | head -n 1 | cut -d'=' -f2)"
		if [[ -z "$MODEL" ]]; then
			echo "ERROR: Could not detect ROM model, setting of kernel failed"
			PRESS_ENTER
			return 1
		fi
		echo
		echo "Detected ROM model: $MODEL"
		if [[ -f "product/$MODEL/KERNEL" ]]; then
			KERNELPATH="$(cat "product/$MODEL/KERNEL")"
			echo "Based on detected ROM model and our little database, your kernel path should be: $KERNELPATH"
		else
			echo "This model does not yet exist in our database. Please fill your kernel path manually"
			echo
			echo "Example for I9300/m0 (Samsung Galaxy S3): /dev/block/mmcblk0p5"
			echo "Example for N9005/hlte (Samsung Note 3): /dev/block/mmcblk0p14"
			echo "Example for E960/mako (LG Nexus 4): /dev/block/platform/msm_sdcc.1/by-name/boot"
			echo
			echo "MAKE SURE THAT THE PATH IS CORRECT, OVERWRITING WRONG PATHS MAY LEAD TO SOFT AND HARD BRICKS"
			read -p "Kernel path for your device: " KERNELPATH
		fi
		SED_CHANGE_WORD "/tmp/invalid_kernel_path" "$KERNELPATH" "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_KERNEL" "^"
		echo
		echo "The final effect is:"
		echo "=-=-=-=-=-=-=-=-="
		cat "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_KERNEL"
		echo
		echo "=-=-=-=-=-=-=-=-="
		echo "Make sure that the command is correct"
		echo "If you need to apply any changes to the generated command, please edit $ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_KERNEL before going to the next step"
		PRESS_ENTER
	fi
}

# Sets modem
SET_MODEM() {
	if [[ -f "$ACTIVE_PROJECT/modem.bin" ]] && ([[ "$(grep -qi "modem.bin" "$ACTIVE_PROJECT/$META_INF/updater-script"; echo $?)" -ne 0 || "$(grep -qi "/tmp/invalid_modem_path" "$ACTIVE_PROJECT/$META_INF/updater-script"; echo $?)" -eq 0 ]]); then
		clear
		PRINT_BANNER
		echo "WARNING! Modem has been found but there's no path in the current updater-script"
		echo "This is typical when you're converting stock image partition to ZIP-flashable ROM"
		local MODEL="$(grep -i "ro.product.device" "$ACTIVE_PROJECT/system/build.prop" | head -n 1 | cut -d'=' -f2)"
		if [[ -z "$MODEL" ]]; then
			echo "ERROR: Could not detect ROM model, setting of modem failed"
			PRESS_ENTER
			return 1
		fi
		echo "Detected ROM model: $MODEL"
		if [[ -f "product/$MODEL/MODEM" ]]; then
			MODEMPATH="$(cat "product/$MODEL/MODEM")"
			echo "Based on detected ROM model and our little database, your modem path should be: $MODEMPATH"
		else
			echo "This model does not yet exist in our database. Please fill your modem path manually"
			echo "Please notice that some models are not supporting flashing a modem via recovery, in such case you should use generic 'NULL' word in this question"
			echo
			echo "Example for I9300/m0 (Samsung Galaxy S3): /dev/block/mmcblk0p7"
			echo "Example for N9005/hlte (Samsung Note 3): NULL"
			echo "Example for E960/mako (LG Nexus 4): /dev/block/platform/msm_sdcc.1/by-name/modem"
			echo
			echo "MAKE SURE THAT THE PATH IS CORRECT, OVERWRITING WRONG PATHS MAY LEAD TO SOFT AND HARD BRICKS"
			read -p "Modem path for your device: " MODEMPATH
		fi
		if [[ "$MODEMPATH" = "NULL" ]]; then
			echo "It looks like your device does not support flashing a modem through recovery, your modem path is NULL"
			rm -f "$ACTIVE_PROJECT/modem.bin" "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_MODEM"
		else
			SED_CHANGE_WORD "/tmp/invalid_modem_path" "$MODEMPATH" "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_MODEM" "^"
			echo
			echo "The final effect is:"
			echo "=-=-=-=-=-=-=-=-="
			cat "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_MODEM"
			echo
			echo "=-=-=-=-=-=-=-=-="
			echo "Make sure that the command is correct"
			echo "If you need to apply any changes to the generated command, please edit $ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_MODEM before going to the next step"
		fi
		PRESS_ENTER
	fi
}

# Creates generic META-INF
BUILD_META_INF() {
	mkdir -p "$ACTIVE_PROJECT/$META_INF"
	cp product/_generic/update-binary "$ACTIVE_PROJECT/$META_INF/update-binary"
	for UPDATER_SCRIPT in "product/_generic/updater-scripts/"*; do
		cp "$UPDATER_SCRIPT" "$ACTIVE_PROJECT/$META_INF/"
	done
}

# Merges updater-scripts from $1 to our ACTIVE_PROJECT
UPDATER_SCRIPT_ADD() {
	local FOLDER="$1"
	local FILE=""
	for UPDATER_SCRIPT in "$FOLDER/updater-script-"*; do
		FILE="$(basename "$UPDATER_SCRIPT")"
		{
			echo "" # This is to ensure that we have a new line BEFORE appending"
			cat "$UPDATER_SCRIPT"
			echo "" # This is to ensure that we have a new line AFTER appending"
		} >> "$ACTIVE_PROJECT/$META_INF/$FILE"
		sed -i '/^$/d' "$ACTIVE_PROJECT/$META_INF/$FILE" # This removes safety lines added above
	done
}

# Reverts merge of updater-scripts from $1 in our ACTIVE_PROJECT
UPDATER_SCRIPT_DEL() {
	local FOLDER="$1"
	local FILE=""
	for UPDATER_SCRIPT in "$FOLDER/updater-script-"*; do
		# TODO: I know that this is slow and inefficient way, however at least I can prove that it's stable and secure
		# If anybody manages to delete lines from $ACTIVE_PROJECT/$META_INF/$FILE, which exist in $UPDATER_SCRIPT, please contribute! :)
		# Unfortunately I failed using sed, so I'm out of better ideas :(
		FILE="$(basename "$UPDATER_SCRIPT")"
		echo -n "" > "$ACTIVE_PROJECT/$FILE"
		while read line; do
			if [[ "$(grep -q "$line" "$UPDATER_SCRIPT"; echo $?)" -eq 1 ]]; then
				echo "$line" >> "$ACTIVE_PROJECT/$FILE"
			fi
		done < "$ACTIVE_PROJECT/$META_INF/$FILE"
		mv -f "$ACTIVE_PROJECT/$FILE" "$ACTIVE_PROJECT/$META_INF/$FILE"
	done
}

# Builds final updater-script from our segments
BUILD_UPDATER_SCRIPT() {
	local HEADER=""
	echo -n "" > "$ACTIVE_PROJECT/$META_INF/updater-script"
	for UPDATER_SCRIPT in "$ACTIVE_PROJECT/$META_INF/updater-script-"*; do
		HEADER="# $(basename "$UPDATER_SCRIPT")"
		{
			echo "" # This is to ensure that we have a new line BEFORE appending"
			echo "$HEADER"
			cat "$UPDATER_SCRIPT"
			echo "" # This is to ensure that we have a new line AFTER appending"
		} >> "$ACTIVE_PROJECT/$META_INF/updater-script"
	done
	sed -i '/^$/d' "$ACTIVE_PROJECT/$META_INF/updater-script" # This removes safety lines added above
	GREP_DELETE_WORD "/tmp/invalid" "$ACTIVE_PROJECT/$META_INF/updater-script" "^" # This is to ensure that we won't pollute our updater-script with invalid paths for kernel or modem
}

# Removes invalid generic permissions
FIX_PERMISSIONS() {
	echo "Right now you're using generic list of permissions based on multiple devices"
	echo "It's usually a good idea to remove invalid permissions, by invalid I mean permissions to non-existent files or folders"
	read -p "Do you want to remove invalid permissions? [Y/n]: " CHOICE
	case "$CHOICE" in
		n|N) ;;
		*)
			cp "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_PERMISSIONS" "$ACTIVE_PROJECT/updater-script-TEMP"
			rm -f "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
			while read perm; do
				perm="$(echo "$perm" | cut -d'"' -f2)"
				if [[ -z "$perm" ]]; then
					continue
				elif [[ ! -e "$ACTIVE_PROJECT$perm" ]]; then
					echo "$perm" >> "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
					grep -v "$perm" "$ACTIVE_PROJECT/updater-script-TEMP" > "$ACTIVE_PROJECT/updater-script-TEMP2"
					mv -f "$ACTIVE_PROJECT/updater-script-TEMP2" "$ACTIVE_PROJECT/updater-script-TEMP"
				fi
			done < "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_PERMISSIONS"
			if [[ ! -e "$ACTIVE_PROJECT/updater-script-TEMP-LIST" ]]; then
				echo "No invalid permissions found, your updater-script is clean!"
				rm -f "$ACTIVE_PROJECT/updater-script-TEMP"
			else
				echo "OK, permissions for following files have been removed from your updater-script: "
				echo "-=-= REMOVED PERMISSIONS START =-=-"
				cat "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
				echo "-=-= REMOVED PERMISSIONS EOF =-=-"
				rm -f "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
				mv -f "$ACTIVE_PROJECT/updater-script-TEMP" "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_PERMISSIONS"
			fi
			PRESS_ENTER
	esac
}

# Removes invalid generic symlinks, adds local ones
FIX_SYMLINKS() {
	echo "Right now you're probably using generic list of symlinks based on multiple devices"
	echo "It's usually a good idea to remove invalid symlinks, by invalid I mean symlinks to non-existent files or folders"
	read -p "Do you want to remove invalid symlinks? [Y/n]: " CHOICE
	case "$CHOICE" in
		n|N) ;;
		*)
			cp "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS" "$ACTIVE_PROJECT/updater-script-TEMP"
			rm -f "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
			local SYMLINKDIR=""
			while read SYMLINK; do
				SYMLINKDIR="$(dirname "$(echo "$SYMLINK" | cut -d'"' -f4)")"
				SYMLINK="$(echo "$SYMLINK" | cut -d'"' -f2)"
				if [[ -z "$SYMLINK" ]]; then
					continue
				elif [[ ! -e "$ACTIVE_PROJECT$SYMLINKDIR/$SYMLINK" ]]; then
					echo "$SYMLINK" >> "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
					grep -v "$SYMLINK" "$ACTIVE_PROJECT/updater-script-TEMP" > "$ACTIVE_PROJECT/updater-script-TEMP2"
					mv -f "$ACTIVE_PROJECT/updater-script-TEMP2" "$ACTIVE_PROJECT/updater-script-TEMP"
				fi
			done < "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS"
			if [[ ! -e "$ACTIVE_PROJECT/updater-script-TEMP-LIST" ]]; then
				echo "No invalid symlinks found, your updater-script is clean!"
				rm -f "$ACTIVE_PROJECT/updater-script-TEMP"
			else
				echo "OK, symlinks for following files have been removed from your updater-script: "
				echo "-=-= REMOVED SYMLINKS START =-=-"
				cat "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
				echo "-=-= REMOVED SYMLINKS EOF =-=-"
				rm -f "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
				mv -f "$ACTIVE_PROJECT/updater-script-TEMP" "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS"
			fi
			PRESS_ENTER
			echo ""
	esac

	echo "We can also add local symlinks from your project, these are available only if your project is based on stock image and contains symlinks inside"
	echo "It's usually a very good idea to add local symlinks, if they're available, in worst case we won't be able to find anything"
	read -p "Do you want to include local symlinks? [Y/n]: " CHOICE
	case "$CHOICE" in
		n|N) ;;
		*)
			local TARGET=""
			local REALPATH=""
			rm -f "$ACTIVE_PROJECT/updater-script-TEMP-LIST" "$ACTIVE_PROJECT/updater-script-TEMP-FOUNDSYMLINKS"
			echo "" >> "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS"
			local MAGIC="0"
			find "$ACTIVE_PROJECT/" -type l | sort | while read SYMLINK; do
				TARGET="$(readlink "$SYMLINK")"
				if [[ "$MAGIC" -eq 0 ]]; then
					# Find proper path
					for ((I=1; MAGIC==0; I++)); do
						if [[ "$(echo "$SYMLINK" | cut -d'/' -f$I)" = "$ACTIVE_PROJECT" ]]; then
							MAGIC="$((I+1))" # We found where ACTIVE_PROJECT is, so now we can set MAGIC right for the next folder
						fi
					done
				fi
				REALPATH="/"
				REALPATH+="$(echo "$SYMLINK" | cut -d'/' -f$MAGIC-)"
				echo "symlink(\"$TARGET\", \"$REALPATH\");" >> "$ACTIVE_PROJECT/updater-script-TEMP-FOUNDSYMLINKS"
				echo "$REALPATH -> $TARGET" >> "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
			done
			if [[ ! -e "$ACTIVE_PROJECT/updater-script-TEMP-LIST" ]]; then
				echo "No local symlinks found, it looks like your build is not based on stock image or local symlinks have been added already"
			else
				echo "Found symlinks:"
				echo "-=-= ADDED SYMLINKS START =-=-"
				cat "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
				echo "-=-= ADDED SYMLINKS EOF =-=-"
				rm -f "$ACTIVE_PROJECT/updater-script-TEMP-LIST"
				PRESS_ENTER
				echo "We managed to find local symlinks. Therefore, if the list is complete we don't need to include all generic symlinks, but just found ones"
				echo "This will result in exact 1:1 copy of all symlinks which are available in system.img, without adding extra ones"
				echo "It's usually a very good idea to keep only found symlinks instead of the whole list, but you may also want to append them to the generic databse instead of making 1:1 copy"
				read -p "Do you want to include only symlinks that were found? [Y/n]: " CHOICE
				case "$CHOICE" in
					n|N) echo "OK, your symlinks have been appended to the generic list"; cat "$ACTIVE_PROJECT/updater-script-TEMP-FOUNDSYMLINKS" >> "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS"; rm -f "$ACTIVE_PROJECT/updater-script-TEMP-FOUNDSYMLINKS" ;;
					*) echo "OK, updater-script now uses only symlinks that were found"; mv -f "$ACTIVE_PROJECT/updater-script-TEMP-FOUNDSYMLINKS" "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS"
				esac
			fi
			PRESS_ENTER
			echo ""
	esac

	echo "Please wait..."
	# Remove duplicated symlinks and sort them
	sort -u < "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS" > "$ACTIVE_PROJECT/updater-script-TEMP"
	mv -f "$ACTIVE_PROJECT/updater-script-TEMP" "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS"

	# Remove local symlinks, we don't need them to pollute our ROM
	find "$ACTIVE_PROJECT/" -type l -delete

	# Remove empty lines, if any
	sed -i '/^$/d' "$ACTIVE_PROJECT/$META_INF/$UPDATER_SCRIPT_SYMLINKS"
}

# Extracts the kernel
KERNEL_EXTRACT() {
	if [[ ! -e "$ACTIVE_PROJECT/kernel" ]]; then
		mkdir -p TEMP
		if [[ ! -e TEMP/mkbootimg ]]; then
			cd tools/kernel/mkbootimg
			make
			if [[ ! -e mkbootimg || ! -e unpackbootimg ]]; then
				echo "ERROR! Something went wrong with compilation of mkbootimg!"
				PRESS_ENTER
				return 1
			fi
			cp mkbootimg ../../../TEMP/mkbootimg
			cp unpackbootimg ../../../TEMP/unpackbootimg
			make clean
			cd ../../..
		fi
		if [[ -e "$ACTIVE_PROJECT/boot.img" ]]; then
			rm -rf "$ACTIVE_PROJECT/kernel"
			mkdir -p "$ACTIVE_PROJECT/kernel"
			TEMP/unpackbootimg -i "$ACTIVE_PROJECT/boot.img" -o "$ACTIVE_PROJECT/kernel"
			mkdir -p "$ACTIVE_PROJECT/kernel/ramdisk"
			if [[ -e "$ACTIVE_PROJECT/kernel/boot.img-ramdisk.gz" ]]; then
				cd "$ACTIVE_PROJECT/kernel/ramdisk"
				#TODO: Handle non-gz ramdisk as well, but not now...
				gunzip -c ../boot.img-ramdisk.gz | cpio -i
				cd ../../..
			fi
		else
			echo "No kernel found!"
			PRESS_ENTER
			return 1
		fi
	fi
}

# Repacks the kernel from previously extracted one
KERNEL_REPACK() {
	if [[ -d "$ACTIVE_PROJECT/kernel" ]]; then
		if [[ -d "$ACTIVE_PROJECT/kernel/ramdisk" ]]; then
			cd "$ACTIVE_PROJECT/kernel/ramdisk"
			find . | cpio -o -H newc | gzip > ../boot.img-ramdisk-NEW.gz
			cd ../../..
			TEMP/mkbootimg --kernel "$ACTIVE_PROJECT/kernel/boot.img-zImage" \
			--ramdisk "$ACTIVE_PROJECT/kernel/boot.img-ramdisk-NEW.gz" \
			--base "$(cat "$ACTIVE_PROJECT/kernel/boot.img-base")" \
			--cmdline "$(cat "$ACTIVE_PROJECT/kernel/boot.img-cmdline")" \
			--kernel_offset "$(cat "$ACTIVE_PROJECT/kernel/boot.img-kerneloff")" \
			--pagesize "$(cat "$ACTIVE_PROJECT/kernel/boot.img-pagesize")" \
			--ramdisk_offset "$(cat "$ACTIVE_PROJECT/kernel/boot.img-ramdiskoff")" \
			--tags_offset "$(cat "$ACTIVE_PROJECT/kernel/boot.img-tagsoff")" \
			-o "$ACTIVE_PROJECT/temp.img"
			mv -f "$ACTIVE_PROJECT/temp.img" "$ACTIVE_PROJECT/boot.img"
		else
			echo "Error, no ramdisk found?!"
			PRESS_ENTER
		fi
		KERNEL_ABORT
	fi
}

# Aborts kernel repacking - performs cleaning
KERNEL_ABORT() {
	rm -rf "$ACTIVE_PROJECT/kernel"
	rm -f "$ACTIVE_PROJECT/temp.img"
}

# Adds kernel's Init.d
INITD() {
	KERNEL_EXTRACT
	if [[ -e kernel/ramdisk/init.rc ]]; then
		sed -i -e '0,/class_start /s//start sysinit\n\n    class_start /' kernel/ramdisk/init.rc
		sed -i -e 's/service media /service sysinit \/system\/bin\/logwrapper \/system\/xbin\/busybox run-parts \/system\/etc\/init.d\n    disabled\n    oneshot\n\nservice media /' kernel/ramdisk/init.rc
		KERNEL_REPACK
		cp -R files/initd/system/* "$ACTIVE_PROJECT/system/"
		UPDATER_SCRIPT_ADD "files/initd/updater-scripts"
	else
		echo "ERROR, no init.rc found?!"
		rm -rf kernel
		PRESS_ENTER
		return 1
	fi
}

# Builds ROM
BUILD() {
	local EXPERT=0
	for ARG in "$@"; do
		case "$ARG" in
			"EXPERT")
				EXPERT=1
		esac
	done
	if [[ "$EXPERT" -eq 0 ]]; then
		FIX_PERMISSIONS
		FIX_SYMLINKS
		BUILD_UPDATER_SCRIPT
		echo "Sometimes kitchen may produce an incorrect updater-script file, that's why you're asked to review updater-script and eventually fix it if needed BEFORE building ROM"
		echo "Updater-script is based on so-called 'segments' available in the same directory - $META_INF"
		echo "Are you ready?"
		PRESS_ENTER
		echo "-=-= UPDATER-SCRIPT START =-=-"
		cat "$ACTIVE_PROJECT/$META_INF/updater-script"
		echo "-=-= UPDATER-SCRIPT EOF =-=-"
		read -p "Are you REALLY sure that above updater-script is correct? ESPECIALLY block-based paths? [Y/n]: " CHOICE
		case "$CHOICE" in
			n|N)
				echo "OK, correct your updater-script and/or it's segments and come back when you're finished"
				PRESS_ENTER
				return 0
		esac
	fi
	local COMPLEVEL="1"
	echo
	echo "Which compression level do you want to use?"
	echo "0 - Store (fastest method, no compression at all)"
	echo "1 - Fastest (fastest type of compression, this is default suggested mode)"
	echo "9 - Best (slowest, maximum compression)"
	echo "You can also type any number between 0-9"
	read -p "CHOICE: " CHOICE
	case "$CHOICE" in
		[0-9]) COMPLEVEL="$CHOICE"
	esac
	cd "$ACTIVE_PROJECT"
	zip -ry -"$COMPLEVEL" "$ACTIVE_PROJECT.zip" . -x "$META_INF/updater-script-"*
	cd ..
	mkdir -p OUTPUT
	mv -f "$ACTIVE_PROJECT/$ACTIVE_PROJECT.zip" "OUTPUT/$ACTIVE_PROJECT.zip"
	echo "Done, your ROM is available in OUTPUT/$ACTIVE_PROJECT.zip"
	read -p "Rename it? [N/y]: " CHOICE
	case "$CHOICE" in
		y|Y)
			read -p "New name: " NAME
			mv -f "OUTPUT/$ACTIVE_PROJECT.zip" "OUTPUT/$NAME"
	esac
	echo "All done, your ROM should be ready!"
	echo "Thank you for using ArchiKitchen!"
	PRESS_ENTER
	exit 0
}

# Deodexes every .odex file
DEODEX() {
	local API="$(grep "ro.build.version.sdk" "$ACTIVE_PROJECT/system/build.prop" | cut -d'=' -f2)"
	echo "Detected API level $API"
	echo "Usually you don't want to change this value"
	read -p "Change it? [N/y]: " CHOICE
	case "$CHOICE" in
		y|Y) read -p "Your selected API level: " API ;;
	esac
	case "$API" in
		[0-9]*) ;;
		*)
			echo "Sorry, it looks like API level is invalid"
			PRESS_ENTER
			return 1
	esac
	find "$ACTIVE_PROJECT" -type f -iname "*.odex" | while read line; do
		local FILE="$(basename "$line")"
		local FILEDIR="$(dirname "$line")"
		echo "Deodexing $FILE"
		echo "Disassembling $FILE..."
		java -Xmx512m -jar tools/smali/baksmali.jar -a "$API" -d "$ACTIVE_PROJECT/system/framework" -x "$FILEDIR/$FILE"
		if [[ $? -ne 0 ]]; then
			echo "ERROR DEODEXING $FILE, ABORTING!"
			rm -rf out
			PRESS_ENTER
			return 1
		fi
		echo "Assembling into classes.dex..."
		java -Xmx512m -jar tools/smali/smali.jar -a "$API" -o classes.dex out
		if [[ ! -e classes.dex ]]; then
			echo "ERROR DEODEXING $FILE, ABORTING!"
			rm -rf out
			PRESS_ENTER
			return 1
		fi
		FILE="$(echo "$FILE" | rev | cut -d'.' -f2- | rev)"
		local FOUND=0
		for EXTENSION in "jar" "apk"; do
			if [[ -e "$FILEDIR/$FILE.$EXTENSION" ]]; then
				echo "Packing back into $FILE.$EXTENSION..."
				zip -rq "$FILEDIR/$FILE.$EXTENSION" classes.dex
				rm -f classes.dex
				FOUND=1
				break
			fi
		done
		if [[ "$FOUND" -eq 0 ]]; then
			echo "ERROR, No output found?!"
			rm -rf out
			rm -f classes.dex
			PRESS_ENTER
			return 1
		fi
		rm -f "$line"
		rm -rf out
	done
	echo "Deodexing finished"
	PRESS_ENTER
}

# Zipaligns single app
ZIPALIGN_APK() {
	echo "Zipaligning $(basename "$1")..."
	"$ZIPALIGN" -f "$ALIGN" "$1" "$1.zipaligned" >/dev/null 2>&1 && mv -f "$1.zipaligned" "$1"
	return $?
}

# Zipaligns everything
ZIPALIGN() {
	if [[ "$FULLPERFORMANCE" -eq 1 ]]; then
		find "$ACTIVE_PROJECT/system" -type f -iname "*.apk" | (while read APK; do
			ZIPALIGN_APK "$APK" &
		done
		wait)
	else
		find "$ACTIVE_PROJECT/system" -type f -iname "*.apk" | while read APK; do
			ZIPALIGN_APK "$APK"
		done
	fi
	echo
	echo "Zipaligning finished!"
	PRESS_ENTER
}

# Adds or removes ArchiDroid's Init.d
ARCHIDROID_INITD() {
	if [[ ! -e "$ACTIVE_PROJECT/system/bin/debuggerd.real" ]]; then
		mv -f "$ACTIVE_PROJECT/system/bin/debuggerd" "$ACTIVE_PROJECT/system/bin/debuggerd.real"
		cp -R files/archidroid/initd/system/* "$ACTIVE_PROJECT/system/"
		UPDATER_SCRIPT_ADD "files/archidroid/initd/updater-scripts"
	else
		mv -f "$ACTIVE_PROJECT/system/bin/debuggerd.real" "$ACTIVE_PROJECT/system/bin/debuggerd"
		UPDATER_SCRIPT_DEL "files/archidroid/initd/updater-scripts"
	fi
	BUILD_UPDATER_SCRIPT
}

# Adds or removes root
ROOT() {
	if [[ ! -e "$ACTIVE_PROJECT/system/xbin/su" ]]; then
		mkdir -p "$ACTIVE_PROJECT/system/xbin"
		cp -R files/root/system/* "$ACTIVE_PROJECT/system/"
		cp -R "files/root/$ARCH/"* "$ACTIVE_PROJECT/"
		cp "$ACTIVE_PROJECT/system/xbin/su" "$ACTIVE_PROJECT/system/xbin/daemonsu"
		mkdir -p "$ACTIVE_PROJECT/system/bin/.ext"
		cp "$ACTIVE_PROJECT/system/xbin/su" "$ACTIVE_PROJECT/system/bin/.ext/.su"
		UPDATER_SCRIPT_ADD "files/root/updater-scripts"
	else
		rm -f "$ACTIVE_PROJECT/system/app/Superuser.apk" "$ACTIVE_PROJECT/system/xbin/su" "$ACTIVE_PROJECT/system/xbin/daemonsu" "$ACTIVE_PROJECT/system/bin/.ext/.su" "$ACTIVE_PROJECT/system/etc/init.d/99SuperSUDaemon" "$ACTIVE_PROJECT/system/etc/.installed_su_daemon"
		UPDATER_SCRIPT_DEL "files/root/updater-scripts"
	fi
	BUILD_UPDATER_SCRIPT
}

# Adds or removes custom bootanimation
BOOTANIMATION() {
	if [[ ! -e "$ACTIVE_PROJECT/system/media/bootanimation.zip" ]]; then
		mv -f "$ACTIVE_PROJECT/system/bin/bootanimation" "$ACTIVE_PROJECT/system/bin/bootanimation.orig"
		cp -R "files/bootanimation/$ARCH/"* "$ACTIVE_PROJECT/"
		cp -R files/bootanimation/common/* "$ACTIVE_PROJECT/"
	else
		mv -f "$ACTIVE_PROJECT/system/bin/bootanimation.orig" "$ACTIVE_PROJECT/system/bin/bootanimation"
		rm -f "$ACTIVE_PROJECT/system/media/bootanimation.zip"
	fi
}

# Adds or removes busybox
BUSYBOX() {
	if [[ ! -e "$ACTIVE_PROJECT/system/xbin/busybox" ]]; then
		cp -R "files/busybox/$ARCH/"* "$ACTIVE_PROJECT/"
		UPDATER_SCRIPT_ADD "files/busybox/updater-scripts"
	else
		rm -f "$ACTIVE_PROJECT/system/xbin/busybox"
		UPDATER_SCRIPT_DEL "files/busybox/updater-scripts"
	fi
	BUILD_UPDATER_SCRIPT
}

# Removes KNOX
REMOVE_KNOX() {
	echo "Removing KNOX..."
	BLACKLIST_REMOVE "knox"
	echo "Done, your ROM should not contain any KNOX apps/folders anymore"
	PRESS_ENTER
}

# Adds or removes insecure ADB
ADB() {
	if [[ -e "$ACTIVE_PROJECT/kernel/ramdisk" ]]; then
		if [[ "$(grep -qi "ro.adb.secure=1" "$ACTIVE_PROJECT/kernel/ramdisk/default.prop"; echo $?)" -eq 0 ]]; then
			SED_CHANGE_WORD "ro.adb.secure=1" "ro.adb.secure=0" "$ACTIVE_PROJECT/kernel/ramdisk/default.prop"
			SED_CHANGE_WORD "ro.secure=1" "ro.secure=0" "$ACTIVE_PROJECT/kernel/ramdisk/default.prop"
		else
			SED_CHANGE_WORD "ro.adb.secure=0" "ro.adb.secure=1" "$ACTIVE_PROJECT/kernel/ramdisk/default.prop"
			SED_CHANGE_WORD "ro.secure=0" "ro.secure=1" "$ACTIVE_PROJECT/kernel/ramdisk/default.prop"
		fi
	fi
}

# Prints banner
PRINT_BANNER() {
	echo "    _             _     _ _  ___ _       _"
	echo "   / \   _ __ ___| |__ (_) |/ (_) |_ ___| |__   ___ _ __"
	echo "  / _ \ | '__/ __| '_ \| | ' /| | __/ __| '_ \ / _ \ '_ \\"
	echo " / ___ \| | | (__| | | | | . \| | || (__| | | |  __/ | | |"
	echo "/_/   \_\_|  \___|_| |_|_|_|\_\_|\__\___|_| |_|\___|_| |_|"
	echo
	echo "Developed by JustArchi"
	echo "Original thread: $XDALINK"
	echo "--------------------------------------------------------------------------------"
}

# Prints status of the project
PRINT_PROJECT_STATUS() {
	ALLFINE=1
	if [[ -d "$ACTIVE_PROJECT/kernel" ]]; then
		ALLFINE=0
		echo "WARNING: Unpacked kernel found"
	fi
	if [[ ! -f "$ACTIVE_PROJECT/boot.img" ]]; then
		ALLFINE=0
		echo "WARNING: No boot.img found, ROM will not boot properly"
	fi
	if [[ ! -d "$ACTIVE_PROJECT/META-INF" ]]; then
		ALLFINE=0
		echo "WARNING: No META-INF folder found, this is not a ROM"
	fi
	echo -n "Project status: "
	if [[ "$ALLFINE" -eq 1 ]]; then
		echo "OK"
	else
		echo "WARNING"
	fi
	echo "--------------------------------------------------------------------------------"
}

# Prints status of the ROM
PRINT_ROM_STATUS() {
	echo -n "Architecture: ["
	if [[ "$ARCH" = "unknown" && -f "$ACTIVE_PROJECT/system/build.prop" ]]; then
		ARCH="$(grep -i "ro.product.cpu.abi" "$ACTIVE_PROJECT/system/build.prop" | head -n 1 | cut -d'=' -f2)"
		if [[ "$(echo "$ARCH" | grep -qi "arm"; echo $?)" -eq 0 ]]; then
			ARCH="arm"
		elif [[ "$(echo "$ARCH" | grep -qi "x86"; echo $?)" -eq 0 ]]; then
			ARCH="x86"
		else
			ARCH="unknown"
		fi
	fi
	echo "$ARCH]"
	echo

	echo -n "ArchiDroid Init.d? "
	if [[ ! -e "$ACTIVE_PROJECT/system/bin/debuggerd.real" ]]; then
		echo "[NO]"
	else
		echo "[YES]"
	fi
	echo -n "Deodexed? "
	if [[ -e "$ACTIVE_PROJECT/system/framework/framework.odex" ]]; then
		echo "[NO]"
	else
		echo "[YES]"
	fi
	echo -n "Zipaligned? "
	if [[ -f "$ACTIVE_PROJECT/system/framework/framework-res.apk" && "$("$ZIPALIGN" -c "$ALIGN" "$ACTIVE_PROJECT/system/framework/framework-res.apk"; echo $?)" -eq 0 ]]; then
		echo "[YES]"
	else
		echo "[NO]"
	fi
	echo -n "Rooted? "
	if [[ ! -e "$ACTIVE_PROJECT/system/xbin/su" ]]; then
		echo "[NO]"
	else
		echo "[YES]"
	fi
	echo -n "Busybox? "
	if [[ ! -e "$ACTIVE_PROJECT/system/xbin/busybox" ]]; then
		echo "[NO]"
	else
		echo "[YES]"
	fi
	echo -n "KNOX? "
	if [[ -f "$ACTIVE_PROJECT/system/app/KNOXAgent.apk" ]]; then
		echo "[YES]"
	else
		echo "[NO]"
	fi
	echo -n "Custom Bootanimation? "
	if [[ ! -e "$ACTIVE_PROJECT/system/media/bootanimation.zip" ]]; then
		echo "[NO]"
	else
		echo "[YES]"
	fi
	if [[ -e "$ACTIVE_PROJECT/kernel/ramdisk" ]]; then
		echo "--------------------------------------------------------------------------------"
		echo -n "ADB? "
		if [[ "$(grep -qi "ro.adb.secure=0" "$ACTIVE_PROJECT/kernel/ramdisk/default.prop"; echo $?)" -eq 0 ]]; then
			echo "[INSECURE]"
		else
			echo "[SECURE]"
		fi
		echo -n "Kernel Init.d? "
		if [[ "$(grep -qi "sysinit" "$ACTIVE_PROJECT/kernel/ramdisk/init.rc"; echo $?)" -eq 0 ]]; then
			echo "[YES]"
		else
			echo "[NO]"
		fi
	fi
	echo "--------------------------------------------------------------------------------"
}

# Prints available switches
PRINT_SWITCHES() {
	echo "adi  - Enable/Disable ArchiDroid Init.d (software debuggerd hook)"
	echo "r    - Enable/Disable Root"
	echo "b    - Enable/Disable Busybox"
	echo "ba   - Enable/Disable Custom Bootanimation"
	echo "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-"
	echo "d    - Deodex Everything"
	echo "z    - Zipalign Everything"
	echo "knox - Remove KNOX"
	echo "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-"
	if [[ -e "$ACTIVE_PROJECT/kernel/ramdisk" ]]; then
		echo "kr   - Repack kernel (apply all ramdisk changes)"
		echo "ka   - Abort repacking (abort all ramdisk changes)"
		echo
		echo "i    - Add Init.d Support (Bugged?) (hardware kernel hook)"
		echo "adb  - Enable/Disable insecure ADB"
	elif [[ -e "$ACTIVE_PROJECT/boot.img" ]]; then
		echo "ku   - Unpack kernel (this enables more options!)"
	fi
	echo "-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-"
	echo "bb   - Build ROM (normal suggested mode)"
	echo "bbe  - Build ROM (expert mode, won't make any checks if your project is OK)"
	echo "--------------------------------------------------------------------------------"
	echo "ak   - Change ArchiKitchen settings"
	echo "x    - Exit"
	echo "--------------------------------------------------------------------------------"
}

# Prints settings of the kitchen
PAGE_SETTINGS() {
	while :; do
		clear
		PRINT_BANNER
		echo -n "Full performance: "
		if [[ "$FULLPERFORMANCE" -eq 1 ]]; then
			echo "[YES]"
		else
			echo "[NO]"
		fi
		echo "--------------------------------------------------------------------------------"
		echo "Full performance mode tries to finish common ArchiKitchen tasks ASAP"
		echo "This includes i.e. calling all job threads at once and waiting for them to"
		echo "finish instead of calling them one-by-one and blocking main thread"
		echo "Due to that, OS may become unresponsive when ArchiKitchen is performing a task"
		echo "Usually it's a good idea to keep it ON, unless you have a very good reason"
		echo "for forcing ArchiKitchen to run in a single-thread mode"
		echo "--------------------------------------------------------------------------------"
		echo "p	- Full performance switch"
		echo "x	- Go back"
		echo "--------------------------------------------------------------------------------"
		read -p "CHOICE: " CHOICE
		case "$CHOICE" in
			p|P)
				if [[ "$FULLPERFORMANCE" -eq 1 ]]; then
					FULLPERFORMANCE=0
				else
					FULLPERFORMANCE=1
				fi
				;;
			x|X) return 0
		esac
	done
}

# Auto-update feature of ArchiKitchen
CHECK_UPDATE() {
	if [[ -d ".git" && ! -z "$(which git)" ]]; then
		echo "Auto-update in progress..."
		local GITVERSION="$(git --version | cut -d' ' -f3)"
		if VERSION_LESS_THAN "$GITVERSION" "$NEEDEDGIT"; then
			echo
			echo "WARNING: Your git version is lower than the required!"
			echo "Your git version: $GITVERSION"
			echo "Required git version: $NEEDEDGIT"
			echo "Auto-update feature has been disabled, please update your git to latest version"
			PRESS_ENTER
			return 0
		fi
		echo "Checking network connection..."
		if [[ "$(wget --spider github.com >/dev/null 2>&1; echo $?)" -ne 0 ]]; then
			echo
			echo "WARNING: Could not connect to github.com, probably your network is down"
			echo "Auto-update feature has been disabled"
			PRESS_ENTER
			return 0
		fi
		local REPO="archikitchen"
		local OLDHEAD="$(git rev-parse HEAD)"
		local CURBRANCH="$(git rev-parse --abbrev-ref HEAD)"
		if [[ "$CURBRANCH" != "$GITHUBBRANCH" ]]; then
			echo "You're currently using $CURBRANCH branch, and this is not the default $GITHUBBRANCH branch. Auto-update feature has been disabled"
			PRESS_ENTER
			return 0
		fi
		if [[ "$(git remote | grep -qi "$REPO"; echo $?)" -ne 0 ]]; then
			git remote add "$REPO" "$GITHUBLINK"
		fi
		echo "Fetching current version..."
		git fetch -q "$REPO" "$GITHUBBRANCH"
		local HEAD="$(git rev-parse "$REPO/$GITHUBBRANCH")"
		if [[ ! -z "$HEAD" && "$OLDHEAD" != "$HEAD" ]]; then
			echo "Found new version!"
			echo "Changelog:"
			echo "=========="
			git --no-pager log --abbrev-commit --decorate --date=relative --pretty=format:'%C(bold red)%h%Creset %C(bold green)(%cr)%Creset - %C(bold yellow)%s%Creset %C(bold blue)commited by%Creset %C(bold cyan)%an%Creset' "$OLDHEAD..$HEAD"
			echo # Beacause git log doesn't finish with newline
			echo "=========="
			git pull -q "$REPO" "$GITHUBBRANCH" >/dev/null 2>&1 || (echo; echo "WARNING: ArchiKitchen could not apply update due to conflicts, forced update mode will be used now. Please make proper backups if you need any of your past projects before going to the next step"; PRESS_ENTER; git reset -q --hard; git clean -qfd; git pull -q "$REPO" "$GITHUBBRANCH")
			echo "ArchiKitchen has been updated, it will now restart itself"
			PRESS_ENTER
			exec "$0"
		else
			echo "No new updates found"
			sleep 1
		fi
	fi
}

############################
#   ____ ___  ____  _____  #
#  / ___/ _ \|  _ \| ____| #
# | |  | | | | |_) |  _|   #
# | |__| |_| |  _ <| |___  #
#  \____\___/|_| \_\_____| #
#                          #
############################

clear
PRINT_BANNER
echo -n "Please wait"

# Before we begin, make sure that all our tools are available
MISSINGTOOLS=""
for TOOL in "${TOOLS[@]}"; do
	echo -n "."
	if [[ -z "$(which $TOOL)" ]]; then
		MISSINGTOOLS+=" $TOOL"
	fi
done
echo ""

if [[ ! -z "$MISSINGTOOLS" ]]; then
	echo "It looks like you don't have required tool(s): $MISSINGTOOLS"
	echo "This check was made through 'which' command"
	echo "Please install missing tool(s) and launch kitchen again"
	exit 1
fi

# Check LONG_BIT for determining host architecture
HOSTARCH="$(getconf LONG_BIT)" # Unused

# Set common tools
ZIPALIGN="./tools/zipalign/zipalign"

# Navigate to our folder, even if user didn't execute it from the root dir
cd "$(dirname "$0")"

# Make sure our tools are executable
# This is only required if user downloaded zip and permissions are broken (f.e. due to moving files from windows => linux)
chmod -R 755 tools

# Parse args
for ARG in "$@"; do
	case "$ARG" in
		"t") AUTOUPDATE="0"; SET_OLDPROJECT ;; # Doesn't check for updates and automatically loads old project, for me to allow faster debugging and testing :)
	esac
done

# Check for updates
if [[ "$AUTOUPDATE" -eq 1 ]]; then
	CHECK_UPDATE
fi

while :; do
	clear
	PRINT_BANNER

	if [[ -z "$ACTIVE_PROJECT" ]]; then
		SET_PROJECT
		continue
	fi

	PRINT_PROJECT_STATUS
	PRINT_ROM_STATUS
	PRINT_SWITCHES
	read -p "CHOICE: " CHOICE
	case "$CHOICE" in
		ak|AK) PAGE_SETTINGS ;;
		adi|ADI) ARCHIDROID_INITD ;;
		r|R) ROOT ;;
		b|B) BUSYBOX ;;
		ba|BA) BOOTANIMATION ;;

		d|D) DEODEX ;;
		z|Z) ZIPALIGN ;;
		knox|KNOX) REMOVE_KNOX ;;

		i|I) INITD ;;
		adb|ADB) ADB ;;
		ku|KU) KERNEL_EXTRACT ;;
		kr|KR) KERNEL_REPACK ;;
		ka|KA) KERNEL_ABORT ;;
		bbe|BBE) BUILD "EXPERT" ;;
		bb|BB)
			if [[ "$ALLFINE" -eq 1 ]]; then
				BUILD
			else
				echo "ERROR: Can't build ROM in actual status, please check warings above and correct them!"
				PRESS_ENTER
			fi
			;;
		x|X) exit 0
	esac
done

exit 0
